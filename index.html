require('dotenv').config();
const bs58 = require('bs58');
const { Keypair, Connection, PublicKey } = require("@solana/web3.js");
const { getOrCreateAssociatedTokenAccount, transfer } = require("@solana/spl-token");
const functions = require("firebase-functions");
const admin = require("firebase-admin");

admin.initializeApp();

const secret = bs58.decode(process.env.SOLANA_PRIVATE_KEY);
const payer = Keypair.fromSecretKey(secret);
const mintAddress = "29ha2CL9u2yA23watQzAUGGnutKDh2GguPK8UzKJbonk";
const connection = new Connection("https://api.mainnet-beta.solana.com", "confirmed");

// 游戏奖励配置
const GAME_CONFIG = {
  TOP20_REWARD_AMOUNT: 30000, // 持仓前20持有者每人奖励30000 TOKENS
  LAST_COUNTDOWN_REWARD_AMOUNT: 100000, // 最后倒计时奖励100000 TOKENS
  TOKEN_DECIMALS: 7, // 代币小数位数
  TOP20_HOLDER_COUNT: 20 // 前20名持有者
};

// 验证用户是否有资格领取持仓前20持有者奖励
async function validateTop20HolderClaim(wallet, roundId) {
  try {
    // 从Firebase获取指定轮次的持仓数据
    const roundRef = admin.database().ref(`holderRewardRounds/${roundId}`);
    const roundSnap = await roundRef.once("value");
    const roundData = roundSnap.val();
    
    if (!roundData || !roundData.top20Holders) {
      throw new Error("轮次数据不存在或无效");
    }
    
    // 检查用户是否在持仓前20中
    const isTop20 = roundData.top20Holders.some(holder => holder.address === wallet);
    if (!isTop20) {
      throw new Error("该地址不在持仓前20持有者中");
    }
    
    // 检查是否已经领取过
    const claimedRef = admin.database().ref(`claimedRewards/top20/${roundId}/${wallet}`);
    const claimedSnap = await claimedRef.once("value");
    if (claimedSnap.exists()) {
      throw new Error("该轮次奖励已领取");
    }
    
    return {
      valid: true,
      roundData: roundData,
      holderData: roundData.top20Holders.find(holder => holder.address === wallet)
    };
  } catch (error) {
    throw new Error(`持仓前20验证失败: ${error.message}`);
  }
}

// 验证用户是否有资格领取最后倒计时奖励
async function validateLastCountdownClaim(wallet, roundId) {
  try {
    // 从Firebase获取指定轮次的倒计时数据
    const roundRef = admin.database().ref(`gameRounds/${roundId}`);
    const roundSnap = await roundRef.once("value");
    const roundData = roundSnap.val();
    
    if (!roundData || !roundData.lastBigBuyAddress) {
      throw new Error("轮次数据不存在或无效");
    }
    
    // 检查用户是否是最后大额买入地址
    if (roundData.lastBigBuyAddress !== wallet) {
      throw new Error("该地址不是最后倒计时地址");
    }
    
    // 检查是否已经领取过
    const claimedRef = admin.database().ref(`claimedRewards/countdown/${roundId}/${wallet}`);
    const claimedSnap = await claimedRef.once("value");
    if (claimedSnap.exists()) {
      throw new Error("该轮次奖励已领取");
    }
    
    return {
      valid: true,
      roundData: roundData,
      lastBuyData: {
        address: roundData.lastBigBuyAddress,
        amount: roundData.lastBigBuyAmount
      }
    };
  } catch (error) {
    throw new Error(`最后倒计时验证失败: ${error.message}`);
  }
}

// 执行代币转账
async function transferTokens(toWallet, amount) {
  try {
    const mint = new PublicKey(mintAddress);
    const toWalletPubkey = new PublicKey(toWallet);

    // 获取或创建用户的ATA
    const toTokenAccount = await getOrCreateAssociatedTokenAccount(
      connection,
      payer,
      mint,
      toWalletPubkey
    );

    // 获取 payer 的ATA
    const fromTokenAccount = await getOrCreateAssociatedTokenAccount(
      connection,
      payer,
      mint,
      payer.publicKey
    );

    // 转账
    const tokenAmount = amount * Math.pow(10, GAME_CONFIG.TOKEN_DECIMALS);
    const sig = await transfer(
      connection,
      payer,
      fromTokenAccount.address,
      toTokenAccount.address,
      payer,
      tokenAmount
    );

    return sig;
  } catch (error) {
    throw new Error(`代币转账失败: ${error.message}`);
  }
}

// 记录奖励领取
async function recordRewardClaim(wallet, roundId, rewardType, amount, txHash) {
  try {
    const claimData = {
      wallet: wallet,
      roundId: roundId,
      rewardType: rewardType,
      amount: amount,
      txHash: txHash,
      claimedAt: Date.now()
    };
    
    // 记录到已领取奖励
    const claimedRef = admin.database().ref(`claimedRewards/${rewardType}/${roundId}/${wallet}`);
    await claimedRef.set(claimData);
    
    // 记录到奖励历史
    const historyRef = admin.database().ref(`rewardHistory`);
    await historyRef.push(claimData);
    
    console.log(`奖励领取记录已保存: ${wallet} - ${rewardType} - ${roundId}`);
  } catch (error) {
    console.error("记录奖励领取失败:", error);
    throw new Error(`记录奖励领取失败: ${error.message}`);
  }
}

// 安全的对象属性检查
function safeHasOwnProperty(obj, key) {
  return obj != null && Object.prototype.hasOwnProperty.call(obj, key);
}

// 清理数据，确保所有值都是可序列化的
function sanitizeData(data) {
  // 处理 null 和 undefined
  if (data === null || data === undefined) {
    return null;
  }
  
  // 处理基本类型
  if (typeof data === 'string' || typeof data === 'number' || typeof data === 'boolean') {
    return data;
  }
  
  // 处理 Date 对象
  if (data instanceof Date) {
    return data.getTime();
  }
  
  // 处理 Buffer 对象
  if (Buffer.isBuffer(data)) {
    return data.toString('base64');
  }
  
  // 处理数组
  if (Array.isArray(data)) {
    return data.map(item => sanitizeData(item)).filter(item => item !== undefined);
  }
  
  // 处理对象
  if (typeof data === 'object' && data !== null) {
    const sanitized = {};
    
    try {
      // 安全地遍历对象属性
      for (const key in data) {
        if (safeHasOwnProperty(data, key)) {
          const value = data[key];
          if (value !== undefined && typeof key === 'string') {
            const sanitizedValue = sanitizeData(value);
            if (sanitizedValue !== undefined) {
              sanitized[key] = sanitizedValue;
            }
          }
        }
      }
      
      // 额外处理 Object.entries 可能遗漏的属性
      const entries = Object.entries(data);
      for (const [key, value] of entries) {
        if (value !== undefined && typeof key === 'string' && !safeHasOwnProperty(sanitized, key)) {
          const sanitizedValue = sanitizeData(value);
          if (sanitizedValue !== undefined) {
            sanitized[key] = sanitizedValue;
          }
        }
      }
      
      return sanitized;
    } catch (error) {
      console.error('对象序列化失败:', error);
      return {};
    }
  }
  
  // 其他类型返回 null
  return null;
}

// 主领取函数
exports.claimGameReward = functions.https.onCall(async (data, context) => {
  try {
    const { wallet, rewardType, roundId } = data;
    
    console.log("claimGameReward收到的参数:", { wallet, rewardType, roundId });
    console.log("使用sanitizeData清理返回数据");
    
    // 参数验证
    if (!wallet) {
      throw new functions.https.HttpsError("invalid-argument", "钱包地址不能为空");
    }
    if (!rewardType || !['top20', 'countdown'].includes(rewardType)) {
      throw new functions.https.HttpsError("invalid-argument", "奖励类型无效，必须是 'top20' 或 'countdown'");
    }
    if (!roundId) {
      throw new functions.https.HttpsError("invalid-argument", "轮次ID不能为空");
    }
    
    let validationResult;
    let rewardAmount;
    
    // 根据奖励类型进行验证
    if (rewardType === 'top20') {
      validationResult = await validateTop20HolderClaim(wallet, roundId);
      rewardAmount = GAME_CONFIG.TOP20_REWARD_AMOUNT;
    } else if (rewardType === 'countdown') {
      validationResult = await validateLastCountdownClaim(wallet, roundId);
      rewardAmount = GAME_CONFIG.LAST_COUNTDOWN_REWARD_AMOUNT;
    }
    
    // 执行代币转账
    const txHash = await transferTokens(wallet, rewardAmount);
    
    // 记录奖励领取
    await recordRewardClaim(wallet, roundId, rewardType, rewardAmount, txHash);
    
    // 返回成功结果 - 确保是纯JSON对象
    const result = {
      success: true,
      txHash: String(txHash || ''),
      rewardType: String(rewardType || ''),
      amount: Number(rewardAmount || 0),
      roundId: String(roundId || ''),
      message: String(rewardType === 'top20' ? 
        `持仓前20持有者奖励领取成功！获得 ${rewardAmount} TOKENS` :
        `最后倒计时奖励领取成功！获得 ${rewardAmount} TOKENS`)
    };
    
    // 多层清理确保完全安全的返回值
    console.log("claimGameReward原始返回数据:", result);
    
    // 第一层：数据清理
    const sanitizedResult = sanitizeData(result);
    console.log("claimGameReward清理后数据:", sanitizedResult);
    
    // 第二层：JSON 序列化清理
    const jsonString = JSON.stringify(sanitizedResult);
    const finalResult = JSON.parse(jsonString);
    console.log("claimGameReward最终返回数据:", finalResult);
    
    // 第三层：确保返回的是纯对象
    return Object.assign({}, finalResult);
    
  } catch (error) {
    console.error("claimGameReward错误:", error);
    throw new functions.https.HttpsError("internal", error.message);
  }
});

// 获取用户可领取的奖励列表
exports.getUserClaimableRewards = functions.https.onCall(async (data, context) => {
  try {
    const { wallet } = data;
    
    if (!wallet) {
      throw new functions.https.HttpsError("invalid-argument", "钱包地址不能为空");
    }
    
    const claimableRewards = {
      top20: [],
      countdown: []
    };
    
    // 获取持仓前20持有者奖励轮次
    const top20RoundsRef = admin.database().ref('holderRewardRounds');
    const top20RoundsSnap = await top20RoundsRef.once("value");
    
    if (top20RoundsSnap.exists()) {
      const top20Rounds = top20RoundsSnap.val();
      for (const [roundId, roundData] of Object.entries(top20Rounds)) {
        if (roundData.top20Holders && roundData.top20Holders.some(holder => holder.address === wallet)) {
          // 检查是否已领取
          const claimedRef = admin.database().ref(`claimedRewards/top20/${roundId}/${wallet}`);
          const claimedSnap = await claimedRef.once("value");
          
          if (!claimedSnap.exists()) {
            claimableRewards.top20.push({
              roundId: roundId,
              timestamp: roundData.timestamp,
              rewardAmount: GAME_CONFIG.TOP20_REWARD_AMOUNT
            });
          }
        }
      }
    }
    
    // 获取最后倒计时奖励轮次
    const countdownRoundsRef = admin.database().ref('gameRounds');
    const countdownRoundsSnap = await countdownRoundsRef.once("value");
    
    if (countdownRoundsSnap.exists()) {
      const countdownRounds = countdownRoundsSnap.val();
      for (const [roundId, roundData] of Object.entries(countdownRounds)) {
        if (roundData.lastBigBuyAddress === wallet) {
          // 检查是否已领取
          const claimedRef = admin.database().ref(`claimedRewards/countdown/${roundId}/${wallet}`);
          const claimedSnap = await claimedRef.once("value");
          
          if (!claimedSnap.exists()) {
            claimableRewards.countdown.push({
              roundId: roundId,
              timestamp: roundData.timestamp,
              rewardAmount: GAME_CONFIG.LAST_COUNTDOWN_REWARD_AMOUNT,
              buyAmount: roundData.lastBigBuyAmount
            });
          }
        }
      }
    }
    
    const result = {
      success: true,
      claimableRewards: claimableRewards,
      totalTop20: Number(claimableRewards.top20.length || 0),
      totalCountdown: Number(claimableRewards.countdown.length || 0)
    };
    
    // 多层清理确保完全安全的返回值
    console.log("getUserClaimableRewards原始返回数据:", result);
    
    // 第一层：数据清理
    const sanitizedResult = sanitizeData(result);
    console.log("getUserClaimableRewards清理后数据:", sanitizedResult);
    
    // 第二层：JSON 序列化清理
    const jsonString = JSON.stringify(sanitizedResult);
    const finalResult = JSON.parse(jsonString);
    console.log("getUserClaimableRewards最终返回数据:", finalResult);
    
    // 第三层：确保返回的是纯对象
    return Object.assign({}, finalResult);
    
  } catch (error) {
    console.error("getUserClaimableRewards错误:", error);
    throw new functions.https.HttpsError("internal", error.message);
  }
});

// 获取轮次详细信息
exports.getRoundDetails = functions.https.onCall(async (data, context) => {
  try {
    const { roundId, rewardType } = data;
    
    if (!roundId || !rewardType) {
      throw new functions.https.HttpsError("invalid-argument", "轮次ID和奖励类型不能为空");
    }
    
    let roundData;
    if (rewardType === 'top20') {
      const roundRef = admin.database().ref(`holderRewardRounds/${roundId}`);
      const roundSnap = await roundRef.once("value");
      roundData = roundSnap.val();
    } else if (rewardType === 'countdown') {
      const roundRef = admin.database().ref(`gameRounds/${roundId}`);
      const roundSnap = await roundRef.once("value");
      roundData = roundSnap.val();
    }
    
    if (!roundData) {
      throw new functions.https.HttpsError("not-found", "轮次数据不存在");
    }
    
    const result = {
      success: true,
      roundData: roundData
    };
    
    // 多层清理确保完全安全的返回值
    console.log("getRoundDetails原始返回数据:", result);
    
    // 第一层：数据清理
    const sanitizedResult = sanitizeData(result);
    console.log("getRoundDetails清理后数据:", sanitizedResult);
    
    // 第二层：JSON 序列化清理
    const jsonString = JSON.stringify(sanitizedResult);
    const finalResult = JSON.parse(jsonString);
    console.log("getRoundDetails最终返回数据:", finalResult);
    
    // 第三层：确保返回的是纯对象
    return Object.assign({}, finalResult);
    
  } catch (error) {
    console.error("getRoundDetails错误:", error);
    throw new functions.https.HttpsError("internal", error.message);
  }
});

// 保留原有的积分兑换函数（如果需要的话）
exports.claimToken = functions.https.onCall(async (data, context) => {
  // 兼容参数被包裹一层的情况
  const wallet = data.wallet || (data.data && data.data.wallet);
  console.log("claimToken收到的wallet:", wallet);
  if (!wallet) {
    throw new functions.https.HttpsError("invalid-argument", "钱包地址不能为空");
  }

  // 读取用户积分（以钱包地址为主键）
  const userRef = admin.database().ref(`users/${wallet}`);
  const userSnap = await userRef.once("value");
  const userData = userSnap.val();
  const score = userData && userData.score ? parseInt(userData.score) : 0;
  if (score <= 0) {
    throw new functions.https.HttpsError("failed-precondition", "没有可兑换的积分");
  }

  try {
    const mint = new PublicKey(mintAddress);
    const toWallet = new PublicKey(wallet);

    // 获取或创建用户的ATA
    const toTokenAccount = await getOrCreateAssociatedTokenAccount(
      connection,
      payer,
      mint,
      toWallet
    );

    // 获取 payer 的ATA
    const fromTokenAccount = await getOrCreateAssociatedTokenAccount(
      connection,
      payer,
      mint,
      payer.publicKey
    );

    // 转账
    // 1积分=10,000,000最小单位（比例再提高10倍，假设decimals=7）
    const decimals = 7;
    const amount = score * Math.pow(10, decimals);
    const sig = await transfer(
      connection,
      payer,
      fromTokenAccount.address,
      toTokenAccount.address,
      payer,
      amount // 1积分=1个token（6位小数）
    );

    // 积分清零
    await userRef.update({
      score: 0,
      lastClaimed: Date.now(),
      lastTx: sig
    });

    const result = { 
      success: true, 
      tx: String(sig || '') 
    };
    
    // 多层清理确保完全安全的返回值
    console.log("claimToken原始返回数据:", result);
    
    // 第一层：数据清理
    const sanitizedResult = sanitizeData(result);
    console.log("claimToken清理后数据:", sanitizedResult);
    
    // 第二层：JSON 序列化清理
    const jsonString = JSON.stringify(sanitizedResult);
    const finalResult = JSON.parse(jsonString);
    console.log("claimToken最终返回数据:", finalResult);
    
    // 第三层：确保返回的是纯对象
    return Object.assign({}, finalResult);
  } catch (e) {
    throw new functions.https.HttpsError("internal", "发币失败: " + e.message);
  }
}); 
